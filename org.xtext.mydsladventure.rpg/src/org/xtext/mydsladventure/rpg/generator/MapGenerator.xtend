/*
 * generated by Xtext 2.15.0
 */
package org.xtext.mydsladventure.rpg.generator

import java.awt.Color
import java.awt.geom.Path2D
import java.awt.image.BufferedImage
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.util.ArrayList
import java.util.HashMap
import javax.imageio.ImageIO
import myDSLAdventure.Exit
import myDSLAdventure.Game
import myDSLAdventure.Room
import myDSLAdventure.RoomList
import org.eclipse.draw2d.graph.DirectedGraph
import org.eclipse.draw2d.graph.DirectedGraphLayout
import org.eclipse.draw2d.graph.Edge
import org.eclipse.draw2d.graph.Node
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.draw2d.geometry.Point

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MapGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var rooms = new ArrayList();
		for (RoomList list : resource.allContents.filter(Game).toIterable.head.gameElementLists.filter(RoomList).toList()) {
			rooms.addAll(list.rooms);
		}
		
		var graph = new DirectedGraph();
		var nodes = new HashMap();
		
		var cg2d = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB).createGraphics();
		
		for (Room r : rooms) {
			var node = new Node(r.name);
			node.width = cg2d.getFontMetrics().stringWidth(r.name) + 20;
			graph.nodes.add(node);
			nodes.put(r.name, node);
		}
		
		for (Room from : rooms) {
			for (Exit to : from.exits) {
				var edge = new Edge(to.action, nodes.get(from.name), nodes.get(to.goto.name));
				edge.setPadding(20);
				graph.edges.add(edge);
			}
		}
		
		var layout = new DirectedGraphLayout();
		layout.visit(graph);
		
		var maxX = 0;
		var maxY = 0;
		
		for (var i = 0; i < graph.nodes.length; i++) {
			var node = graph.nodes.getNode(i);
			maxX = Math.max(maxX, node.x + node.width);
			maxY = Math.max(maxY, node.y + node.height);
		}
		
		var bufferedImage = new BufferedImage(maxX + 80, maxY + 80, BufferedImage.TYPE_INT_ARGB);

	    var g2d = bufferedImage.createGraphics();
	    
	    g2d.background = Color.LIGHT_GRAY;
	    g2d.clearRect(0, 0, bufferedImage.width, bufferedImage.height);
	    g2d.setColor(Color.black);
	    
		for (var i = 0; i < graph.nodes.length; i++) {
			var node = graph.nodes.getNode(i);
			g2d.setColor(Color.white);
			g2d.fillRoundRect(node.x + 20, node.y + 20, node.width, node.height, 5, 5);
			g2d.setColor(Color.black);
			g2d.drawRoundRect(node.x + 20, node.y + 20, node.width, node.height, 5, 5);
	    	g2d.drawString(node.data.toString(), node.x + 10 + 20, node.y + node.height / 2 + 20);
		}
		
		for (var i = 0; i < graph.edges.length; i++) {
			var edge = graph.edges.getEdge(i);
			var path = new Path2D.Double();
			
			var vNodes = edge.vNodes;
			
			path.moveTo(edge.points.getPoint(0).x + 20, edge.points.firstPoint.y + 20);
			for (var p = 1; p < edge.points.size; p++) {
				var point = edge.points.getPoint(p);
				path.lineTo(point.x + 20, point.y + 20);
			}
			g2d.setColor(Color.black);
			g2d.draw(path);			
		}

	    g2d.dispose();
	    
	    var baos = new ByteArrayOutputStream();
	    ImageIO.write(bufferedImage, "png", baos);
		var stream = new ByteArrayInputStream(baos.toByteArray());
		
		fsa.generateFile(resource.URI.trimFileExtension.segment(resource.URI.trimFileExtension.segmentCount - 1) + "_map.png", stream);
	}
	
}
